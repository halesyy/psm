# PSM
## Intro
PSM is a PDO (PHP Database Objects) re-write, to add another layer of abstraction to your database connections, without slowing performance.

PSM tries to make you think for the quickest and less code-used solutions to your problems, creating easy-to-read statements easily integrated into any environment, from auto-binding queries allowing no SQL-Injection to creating chain functions to build statements then run the outcomse!

## Install
PSM3 is defaulted with 3 MAIN files, and an OPTIONAL 4th file. These files are located in the **classes** folder of the project, and the files (*to load in order*) are, **PSMExtra**, **PSMQuery** and **PSMMain**.

There's two ways to go-about creating your PSM3 class instance, you can either connect to a database in the constructor, or create your class instance then later connect. - This was not possible in older versions of PSM. (The third option is for database migration)

**Before starting, make sure you've included your files!**:
```php
require_once('classes/PSMExtra.php');
require_once('classes/PSMQuery.php');
require_once('classes/PSMMain.php');
```
### Connecting straight from the constrcutor
```php
$psm = new PSM('HOSTNAME DATABASE USERNAME PASSWORD');
// If your password is empty, use the 'EM' keyword in password to emulate an empty space.
$psm->version();
```

### Connecting after creating the instance
```php
$psm = new PSM;
$psm->connect('HOSTNAME DATABASE USERNAME PASSWORD');
$psm->version();
```

### Connecting using a capsule
```php
// A capsule is a simple string generated by $psm->capsule() when on a server running PSM.
$psm = new PSM;
// Capsule would be generated from another server.
$capsule = "PSM_DB_CAPSULE{HOSTNAME::DATABASE::USERNAME::PASSWORD}";
$psm->decapsule($capsule);
```

And there you have it! A simple **PSM** connection! Any 3 of these solutions to creating your instance is always going to be quick, and you can easily get your PDO handler simply by using:

```php
$pdo = $psm->handler;
```

So, this can always be used as a way to generate PDO handlers.

## Documentation
When making a new PSM object, you are given a lot of functions :smirk:

> **If you don't really know any PHP OOP, I recommend you understand how classes work and functions work together, you can read up on it [here - php manual](http://php.net/manual/en/language.oop5.php) or [here - youtube tutorial](https://www.youtube.com/watch?v=ipp4WPDwwvk&list=PLfdtiltiRHWF0RicJb20da8nECQ1jFvla)**

To make a simple PSM object just do the following code, and we can inspect it after:
**(Make sure to require the PSM files as done in the install section)**

### How to add a driver
```php
$psm = new PSM('localhost test root EM',[
  'safeconnection' => false
]);
```
Drivers are something I've never spent a lot of time using/creating, but would be appreciated if added to a PR.

## PSM3 Function Analysis

| Function | Description |
| -------- | ----------- |
| version | Displays the version of the current PSM instance instantiated. |
| qa / help | Query analysis - Will take in a prepared statement and analyze error messages, and report back. |
| cquery | First param is the statement, second param is the binder to the query. Binder is optional if you want a base query. |
| cstatement | Array-to-statement generator, example input ```['select' => 'users', 'where' => 'id = 1']; ``` will create a statement judging from the array inputs. |
| short_csatement | Array-to-statement generator but smaller array, example input ```['users','username','id = 1']; ``` will create **SELECT username FROM users WHERE id = 1**. |
| stat | Does a simple static function, prepares and binds the query, i.e. an **INSERT** statement is static. |
| set | Takes in a statement and optional binding to create a query and return the first row in an ASSOCIATIVE array. |
| rows | Returns the row count of the statement and binds supplied to create the query. |
| hasdata | Shorthand rows function but will check if there's any rows, if so return **true** / **false**. |
| hasnodata | Opposite of hasdata. |
| hasdata_specific | Takes in table, column, what the column has to equal to, and callers, looks in table column for specific data, if so will return true or false, if the 4th paramater is supplied, will call a 'true' or 'false' array callback. ```['true' => FUNCTION, 'false' => FUNCTION] ``` |
| query_rows | Rows function but if you have created a query. |
| info | If you set the first paramater to true, displays all functions in PSM as well as some other inforamtion about the class, if set to false will just show number of functions. |
| get_cols | Takes in a table as it's first paramater, will return the column names of the table. |
| table_exists | Returns bool of true or false if the table is existant in the current database. |
| update | Shorthand **UPDATE** statement function, takes in a table as the first paramater and an array as the second, the array needs to contain columns as keys and data as rows, then the third paramater must be a where statement built as a clause following the form of **COLUMN = DATA**, and no other exceptions - Fourth paramater is debug, set to true if you wanna see the statement / binds auto-generated from the function. |
| delete | Takes in first paramater as the table name, if nothing else is given will simply delete the entire table - Second paramater is the column you want to look in, and the selectors as the third paramater, meaning you can run: ```$psm->delete('users', 'id' [1,2,3]);``` Which will simply delete users with ID's of 1, 2 or 3. |
| get_column_data | Looks in a table then the column, then returns a numerative array of all the data in that row, i.e. Get all usernames from the table users. |
| data | Takes in statement and bind as both paramaters, and returns array containing the actual query itself, rowcount, queryset/set, statement and the binds of the query. |
| insert | Runs similar to the update function where it performs an insert on the table given in the first paramater, then uses the array keys as columns and values as data, third paramater is debug. |
| capsule | Run to store your current database inforamtion in a string, use to migrate or **capsule your connection for later-use**.
| decapsule | Uses data generated from **capsule** to re-create a connection. |

### More on capsules (and serializing the PSM variable)
#### Seems pretty useless to take a string and put it on another server to act as the serve, right?
Well, this wasn't the main aim for building the capsule function, the aim was to be able to store that capsule data to later re-construct the connection, but even now there's an easier way to do that, so I'll show you both ways. (please don't store stuff like database connectors in session, just don't, this is just an example)

```php
$_SESSION['psm'] = $psm->capsule();
$psm = false;
// do some stuff over pages
. . .
// oo! we need psm again!
$psm = new PSM;
$psm->decapsule($_SESSION['psm']);
$psm->version();
```
But that's a bit... edgy... So use this way!
```php
$psm->close();
$_SESSION['psm'];
// do some stuff over pages
. . .
// oo! we need psm again!
$psm = $_SESSION['psm']->open();
$psm->version();
```
That way you're storing your entire class in the variable, even safer!

